<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Linux 内核设计与实现">
<meta property="og:type" content="article">
<meta property="og:title" content="Studio Blog">
<meta property="og:url" content="http://example.com/2025/08/02/Linux%20%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Studio Blog">
<meta property="og:description" content="Linux 内核设计与实现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\ASUS\Documents\%E7%AC%94%E8%AE%B0\19113723-21463cd0f94f455480d282ac1b38138d.png">
<meta property="og:image" content="c:\Users\ASUS\Documents\%E7%AC%94%E8%AE%B0\23111716-dc0f4c90540c48569dd18f835b2d8af9.png">
<meta property="article:published_time" content="2025-08-02T08:19:38.980Z">
<meta property="article:modified_time" content="2025-08-09T04:32:32.321Z">
<meta property="article:author" content="gb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\ASUS\Documents\%E7%AC%94%E8%AE%B0\19113723-21463cd0f94f455480d282ac1b38138d.png">

<link rel="canonical" href="http://example.com/2025/08/02/Linux%20%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | Studio Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Studio Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/02/Linux%20%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/20210404011504_4219e.png">
      <meta itemprop="name" content="gb">
      <meta itemprop="description" content="路漫漫其修远兮">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Studio Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-08-02 16:19:38" itemprop="dateCreated datePublished" datetime="2025-08-02T16:19:38+08:00">2025-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-08-09 12:32:32" itemprop="dateModified" datetime="2025-08-09T12:32:32+08:00">2025-08-09</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Linux-内核设计与实现"><a href="#Linux-内核设计与实现" class="headerlink" title="Linux 内核设计与实现"></a>Linux 内核设计与实现</h1> <span id="more"></span>

<h2 id="第三章-进程管理"><a href="#第三章-进程管理" class="headerlink" title="第三章 进程管理"></a>第三章 进程管理</h2><p> 主要讲了进程相关。什么是进程？进程描述及结构，如何创建进程？</p>
<h3 id="3-1进程"><a href="#3-1进程" class="headerlink" title="3.1进程"></a>3.1进程</h3><ul>
<li>进程是什么？<blockquote>
<p>进程是执行期的程序以及它所使用的资源的总称。</p>
</blockquote>
</li>
<li>线程是什么？<blockquote>
<p>进程中的活动对象，执行单位。每个线程都有独立的程序计数器，进程栈和一组进程寄存器，共享进程的资源。内核调度的对象是线程。对linux来说，线程是一种特殊的进程。</p>
</blockquote>
</li>
</ul>
<h3 id="3-2-进程描述符和任务结构"><a href="#3-2-进程描述符和任务结构" class="headerlink" title="3.2 进程描述符和任务结构"></a>3.2 进程描述符和任务结构</h3><p>内核把进程的列表存放在任务列表的双向循环链表中。表中的每一项都是<code>task_struct</code>，进程描述符，用来管理一个进程，包含管理进程的所有信息。包含的数据能够描述一个正在执行的程序。如进程打开的文件，状态，地址空间等等。<br>通过slab分配器分配<code>task_struct</code>结构。一般放到栈的最后。 </p>
<p>在内核中 一般用宏<code>current</code>查找到正在运行进程的进程描述符。</p>
<h3 id="3-3-进程的状态"><a href="#3-3-进程的状态" class="headerlink" title="3.3 进程的状态"></a>3.3 进程的状态</h3><p>运行 可中断 不可中断 trace追踪 停止。</p>
<p>内核使用<code>set_task_state(task,state)</code>函数来调整进程的状态。</p>
<h3 id="3-4-进程的家族数"><a href="#3-4-进程的家族数" class="headerlink" title="3.4 进程的家族数"></a>3.4 进程的家族数</h3><p>所有的linux进程，都是init进程的后代。linux中每个进程必有一个父进程和若干个子进程。其关系置于进程描述符中，包含一个指向父进程的task_struct的parent指针，和称为children 的<strong>子进程链表</strong></p>
<h3 id="3-5-进程的创建"><a href="#3-5-进程的创建" class="headerlink" title="3.5 进程的创建"></a>3.5 进程的创建</h3><p>unix采用独特的进程创建方式，使用两个系统调用创建进程，读取可执行文件。<strong>frok()拷贝当前进程创建一个子进程，此时子进程和父进程的区别只在于pid和某些资源与统计量。然后执行exec函数负责读取可执行文件将其装入地址空间开始运行。</strong></p>
<p>frok()使用了一种<strong>写时拷贝</strong>的技术。不复制整个进程地址空间，而是父子共享。在需要写入的时候，才复制，从而使各个进程各自用于各自的拷贝。（ 疑惑？父进程写入的时候子进程也拷贝吗？）</p>
<ol>
<li>首先调用dup_task_struct为新进程创建内核栈，thread_info和task_struct。这些值和当前进程的值一致，且此时进程描述符也是完全相同的。</li>
<li>检查有没有超出用户最大的的进程资源数量。</li>
</ol>
<h2 id="第四章-进程调度"><a href="#第四章-进程调度" class="headerlink" title="第四章 进程调度"></a>第四章 进程调度</h2><p>绝大多数可以在内核之旅的读书笔记上看，这里只做自己不理解的比较细节的问题的解答，及上面没有的补充。</p>
<ul>
<li><p>进程也可以分类，io消耗型和处理器消耗型，但这两者并不互斥。</p>
</li>
<li><p>两种调度优先级，一种内核的nice值，越小优先级越大，另一种是实时优先级，实时优先级数值越高优先级越高，这两个是互斥的，有nice则无实时优先级。有实时优先级说明是实时进程，实时进程的优先级都高于普通进程。nice值的是普通进程。</p>
<blockquote>
<p>在 Linux 系统中，实时进程是指具有严格时间约束、优先级高于普通进程的特殊进程，其设计目标是确保在指定时间内完成任务，避免因调度延迟导致功能失效。</p>
</blockquote>
</li>
<li><p>首先我们知道CFS是个什么，它是linux的调度器的一个模块，一个调度器类，只调度属于自己范畴的进程，CFS是一个针对<strong>普通进程</strong>的调度器类。对于进程调度，设计为分配给进程一个处理器的使用比例而非固定时间片。这个使用比列是在<strong>调度周期</strong>里的。<strong>调度周期是指 CFS 调度器将 CPU 时间分配给所有可运行进程的总时间长度。在一个调度周期内，每个进程按其权重获得相应的 CPU 时间片。</strong>  <strong>目标延迟是指 CFS 调度器保证的、任意进程等待 CPU 的最大时间上限。当系统中进程数较少时，调度周期会收敛到目标延迟，确保低负载下的响应性</strong> 为了防止进程数量趋于无限，所有任务都获得的使用比和时间都趋于零，会有一个<strong>最小粒度</strong>，用来保证任务进程能获得的时间片的底线。最小粒度是 CFS 调度器中控制时间片下限的关键参数，它通过限制单个进程的最小执行时间，平衡了系统的公平性与切换开销。</p>
</li>
<li><p>什么是虚拟实时？</p>
<blockquote>
<p>虚拟实时是 CFS 调度器为每个进程维护的一个虚拟运行时间，它将物理 CPU 时间根据进程优先级（权重）进行了归一化，CFS使用vruntime变量来记录一个程序到底运行了多长时间以及它还应该再运行多久。<strong>对于vruntime的更新逻辑不太明白，还有加权计算，留待深入了解时再来补写</strong>.</p>
<p>使用update_curr来实时更新当前运行进程的虚拟时间(这个是由系统定时器周期性调用的.)    </p>
<ul>
<li>根据当前进程的<strong>物理执行时间</strong>和<strong>权重</strong>，计算并累加其 vruntime。</li>
<li>公式：<code>Δvruntime = (物理时间 × NICE_0_LOAD) / 进程权重</code></li>
</ul>
</blockquote>
</li>
<li><p>调度时靠红黑树,用一个最最子节点的缓存来选择下一个要调度的进程,选择拥有最小vruntime的进程 </p>
</li>
<li><p>调度器入口是Schedule(),通常都会和一个具体的调度类相关联,也就是说,它会找到一个最高优先级的调度类,调度类要有自己的可运行队列.</p>
</li>
</ul>
<h2 id="第七章-中断处理"><a href="#第七章-中断处理" class="headerlink" title="第七章 中断处理"></a>第七章 中断处理</h2><ol>
<li><p>什么是中断？</p>
<p>中断机制是硬件在需要的时候向CPU发出信号，cpu暂停正在进行的工作，来处理硬件请求的一种机制。</p>
<p>详细点的就是硬件向中断控制器的输入引脚发送一个信号，中断控制器会给cpu发送一个电信号，cpu检测到这个信号，就会停止当前的工作，转而处理中断，此后处理器会通知操作系统已经产生中断，这样，操作系统就可以对这个中断进行处理。</p>
</li>
<li><p>中断处理程序</p>
<p>在相应特定在中断的时候，内核会执行一个函数，该函数叫做中断处理函数。产生中断的每一个设备都有一个相应的中断处理函数。中断处理程序运行在中断上下文中（处理器相应中断所处的特殊执行环境）</p>
<p>中断上下文与进程上下文的对比</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>中断上下文</th>
<th>进程上下文</th>
</tr>
</thead>
<tbody><tr>
<td>所属主体</td>
<td>内核（与 CPU 绑定）</td>
<td>具体用户进程或内核线程</td>
</tr>
<tr>
<td>栈空间</td>
<td>内核固定大小栈（CPU 专属）</td>
<td>进程的用户栈或内核栈（动态大小）</td>
</tr>
<tr>
<td>阻塞操作</td>
<td>不允许（会导致系统问题）</td>
<td>允许（如等待 I&#x2F;O、睡眠）</td>
</tr>
<tr>
<td>执行时间</td>
<td>必须极短（毫秒级内）</td>
<td>可长可短（取决于进程任务）</td>
</tr>
<tr>
<td>内存访问</td>
<td>仅能访问内核空间</td>
<td>可访问用户空间和内核空间</td>
</tr>
<tr>
<td>典型操作</td>
<td>设备数据读取、中断标志清除</td>
<td>进程调度、系统调用、内存管理等</td>
</tr>
</tbody></table>
</li>
<li><p>中断类型</p>
<p>中断一般分为异步中断(一般由硬件引起)和同步中断(一般由处理器本身引起)。</p>
<p>异步中断：CPU处理中断的时间过长，所以先将硬件复位，使硬件可以继续自己的工作，然后在适当时候处理中断请求中耗时的部分。</p>
<p>举个例子：网卡的工作原理</p>
<ol>
<li>网卡收到数据包后，向CPU发出中断信号，请求处理接收到的数据包</li>
<li>CPU将收到的数据包拷贝到内存后，即通知网卡继续工作 （上半部）</li>
<li>至于数据包拷贝至内存后的处理会在适当的时候进行  (下半部)</li>
</ol>
<p>这样做避免了处理数据包时间过长导致网卡接收数据包速度变慢。</p>
<p>同步中断：CPU处理完中断请求的所有工作后才反馈硬件</p>
<p>举个例子：系统异常处理(比如运算中的除0操作)</p>
<ol>
<li>应用程序出现异常后，需要内核来处理</li>
<li>内核调用相应的异常处理函数来处理异常</li>
<li>处理完后终了应用程序或者给出message</li>
</ol>
<p>同步中断应该处理能很快完成的一种中断</p>
</li>
<li><p>中断上半部和下半部</p>
<p>上半部只在硬件中断上下文中运行，实时性要求极高，必须立即执行。特点是执行时间短，只处理最紧急，以避免阻塞其他。执行期间禁止同级或更低优先级的中断，但是可能允许更高优先级的中断。</p>
<p>下半部在非中断上下运行，比如进程上下文，允许延迟执行，可处理耗时任务。处理上半部未完成的较为复杂的任务，如对网络卡接收到的数据包进行详细解析、处理和存储等。</p>
</li>
<li><p>中断相关函数</p>
<p>实现一个中断，主要需要三个函数</p>
<ul>
<li>注册中断的函数</li>
<li>释放中断的函数</li>
<li>中断处理程序的声明</li>
</ul>
<p>5.1 注册中断的函数</p>
<p>位置： &lt;linux&#x2F;interrupt.h&gt; include&#x2F;linux&#x2F;interrupt.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * irg     - 表示要分配的中断号</span></span><br><span class="line"><span class="comment"> * handler - 实际的中断处理程序</span></span><br><span class="line"><span class="comment"> * flags   - 标志位，表示此中断的具有特性</span></span><br><span class="line"><span class="comment"> * name    - 中断设备名称的ASCII 表示，这些会被/proc/irq和/proc/interrupts文件使用</span></span><br><span class="line"><span class="comment"> * dev     - 用于共享中断线，多个中断程序共享一个中断线时(共用一个中断号)，依靠dev来区别各个中断程序</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> * 执行成功：0</span></span><br><span class="line"><span class="comment"> * 执行失败：非0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 分配一条给定的中断线*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">                <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">char</span>* name,</span></span><br><span class="line"><span class="params">                <span class="type">void</span> *dev)</span></span><br></pre></td></tr></table></figure>

<p>5.2 释放中断的函数</p>
<p>定义比较简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev)</span></span><br></pre></td></tr></table></figure>

<p>如果不是共享中断线，则直接删除irq对应的中断线。</p>
<p>如果是共享中断线，则判断此中断处理程序是否中断线上的最后一个中断处理程序，</p>
<p>是最后一个中断处理程序 -&gt; 删除中断线和中断处理程序</p>
<p>不是最后一个中断处理程序 -&gt; 删除中断处理程序</p>
<p>5.3 中断处理程序的声明</p>
<p>声明格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 中断处理程序的声明</span></span><br><span class="line"><span class="comment"> * @irp  - 中断处理程序(即request_irq()中handler)关联的中断号</span></span><br><span class="line"><span class="comment"> * @dev  - 与 request_irq()中的dev一样，表示一个设备的结构体</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> * irqreturn_t -  执行成功：IRQ_HANDLED  执行失败：IRQ_NONE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">intr_handler</span><span class="params">(<span class="type">int</span>, irq, <span class="type">void</span> *dev)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>中断处理机制</p>
<p>中断处理的过程主要涉及函数：</p>
<ul>
<li>do_IRQ 与体系结构有关，对所接收的中断进行应答</li>
<li>handle_IRQ_event 调用中断线上所有中断处理</li>
<li>ret_from_intr 恢复寄存器，将内核恢复到中断前的状态。</li>
</ul>
<p><img src="C:\Users\ASUS\Documents\笔记\19113723-21463cd0f94f455480d282ac1b38138d.png" alt="img"></p>
</li>
</ol>
<blockquote>
<p>1.<strong>中断触发阶段</strong></p>
<ul>
<li><strong>硬件信号</strong>：外部设备（如键盘、网卡、定时器）通过中断控制器（如 8259A 或 APIC）向 CPU 发送中断请求信号（IRQ）。</li>
<li><strong>中断向量号</strong>：每个中断源对应一个唯一的<strong>中断向量号</strong>（如键盘中断为 0x21），用于标识中断类型。</li>
<li><strong>边沿 &#x2F; 电平触发</strong>：中断信号可以是边沿触发（如上升沿）或电平触发（如高电平持续），取决于硬件设计。</li>
</ul>
<ol start="2">
<li><strong>CPU 响应阶段</strong></li>
</ol>
<ul>
<li><strong>检测中断</strong>：CPU 在每条指令执行结束后，检查中断引脚是否有信号。</li>
<li>&#x2F;<strong>保存上下文</strong>：若有中断请求且 CPU 允许响应（IF 标志位为 1），则暂停当前程序，保存<strong>硬件上下文</strong>（如寄存器值、FLAGS 标志、CS:IP 指令指针）到内核栈。</li>
<li><strong>关中断</strong>：响应中断时，CPU 自动清除 IF 标志（CLI 指令），禁止同级或低级中断干扰，确保原子性。</li>
<li><strong>获取中断向量</strong>：根据中断向量号，从<strong>中断向量表</strong>（IVT，实模式）或<strong>中断描述符表</strong>（IDT，保护模式）中查找对应的中断处理程序地址。</li>
</ul>
<ol start="3">
<li><strong>中断处理程序执行阶段</strong></li>
</ol>
<ul>
<li><p><strong>跳转到 ISR</strong>：CPU 将控制权转移到中断服务程序（ISR，Interrupt Service Routine）的入口地址。</p>
</li>
<li><p>中断上下文建立：</p>
</li>
<li><p>保存更多寄存器值到内核栈（如通用寄存器 eax、ebx 等）。</p>
</li>
<li><p>设置内核栈指针，切换到中断处理专用栈（避免与进程栈冲突）。</p>
</li>
<li><p>中断处理分阶段：</p>
</li>
<li><p><strong>上半部（Top Half）</strong>：快速执行紧急任务（如读取设备数据、清除中断标志），通常禁止中断。</p>
</li>
<li><p><strong>下半部（Bottom Half）</strong>：将耗时操作推迟到非关键路径（如数据处理、唤醒等待进程），通过软中断、tasklet 或工作队列实现。</p>
</li>
<li><p><strong>中断返回</strong>：执行 IRET&#x2F;IRETD 指令，恢复硬件上下文（寄存器值、FLAGS、CS:IP），重新开中断（IF 标志恢复）。</p>
</li>
</ul>
<ol start="4">
<li><strong>中断嵌套与优先级</strong></li>
</ol>
<ul>
<li><strong>多级中断</strong>：现代 CPU 支持多级中断优先级（如 x86 的 IRQL 机制），高优先级中断可抢占低优先级中断。</li>
<li><strong>中断屏蔽</strong>：通过设置中断控制器的屏蔽位（如 8259A 的 IMR 寄存器），可选择性屏蔽某些中断源。</li>
</ul>
</blockquote>
<ol start="7">
<li>中断控制的方法</li>
</ol>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>local_irq_disable()</td>
<td>禁止本地中断传递</td>
</tr>
<tr>
<td>local_irq_enable()</td>
<td>激活本地中断传递</td>
</tr>
<tr>
<td>local_irq_save()</td>
<td>保存本地中断传递的当前状态，然后禁止本地中断传递</td>
</tr>
<tr>
<td>local_irq_restore()</td>
<td>恢复本地中断传递到给定的状态</td>
</tr>
<tr>
<td>disable_irq()</td>
<td>禁止给定中断线，并确保该函数返回之前在该中断线上没有处理程序在运行</td>
</tr>
<tr>
<td>disable_irq_nosync()</td>
<td>禁止给定中断线</td>
</tr>
<tr>
<td>enable_irq()</td>
<td>激活给定中断线</td>
</tr>
<tr>
<td>irqs_disabled()</td>
<td>如果本地中断传递被禁止，则返回非0；否则返回0</td>
</tr>
<tr>
<td>in_interrupt()</td>
<td>如果在中断上下文中，则返回非0；如果在进程上下文中，则返回0</td>
</tr>
<tr>
<td>in_irq()</td>
<td>如果当前正在执行中断处理程序，则返回非0；否则返回0</td>
</tr>
</tbody></table>
<h2 id="第八章-下半部分和推后执行的工作"><a href="#第八章-下半部分和推后执行的工作" class="headerlink" title="第八章 下半部分和推后执行的工作"></a>第八章 下半部分和推后执行的工作</h2><h3 id="1-中断下半部处理"><a href="#1-中断下半部处理" class="headerlink" title="1. 中断下半部处理"></a><strong>1. 中断下半部处理</strong></h3><p>那么对于一个中断，如何划分上下两部分呢？哪些处理放在上半部，哪些处理放在下半部？</p>
<p>这里有一些经验可供借鉴：</p>
<ol>
<li>如果一个任务对时间十分敏感，将其放在上半部</li>
<li>如果一个任务和硬件有关，将其放在上半部</li>
<li>如果一个任务要保证不被其他中断打断，将其放在上半部</li>
<li>其他所有任务，考虑放在下半部</li>
</ol>
<p>上半部分完成绝对中断的及时相应，比如操作硬件对中断的到达确认，从硬件中拷贝数据。</p>
<p>下半部的任务就是执行和中断处理密切相关但中断处理程序本身不执行的工作。</p>
<h3 id="2-实现中断下半部的机制"><a href="#2-实现中断下半部的机制" class="headerlink" title="2. 实现中断下半部的机制"></a><strong>2. 实现中断下半部的机制</strong></h3><p>实现下半部的方法很多，随着内核的发展，产生了一些新的方法，也淘汰了一些旧方法。</p>
<p>目前使用最多的是以下3种方法</p>
<ul>
<li>2.1 软中断</li>
<li>2.2 tasklet</li>
<li>2.3 工作队列</li>
</ul>
<h4 id="2-1-软中断"><a href="#2-1-软中断" class="headerlink" title="2.1 软中断"></a>2.1 软中断</h4><p>软中断是子啊编译期间静态分配的。</p>
<p>其流程如图所示：</p>
<p><img src="C:\Users\ASUS\Documents\笔记\23111716-dc0f4c90540c48569dd18f835b2d8af9.png" alt="23111716-dc0f4c90540c48569dd18f835b2d8af9.png (543×358)"></p>
<p>在编译期间，有个枚举类型静态声明软中断，内核用这些从0开始的索引标识一种相对优先级。索引号小的软中断在索引号大的软中断之前执行。软中断类型通过<code>enum</code>枚举定义，每个枚举值对应一个唯一的软中断编号。例如，在<code>include/linux/interrupt.h</code>中：建立一个新的软中断必须在此枚举类型种加入新的项。</p>
<p>内核维护一个全局数组<code>softirq_vec</code>，每个数组元素对应一个软中断处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>] __<span class="title">cacheline_aligned_in_smp</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>NR_SOFTIRQS</code>表示软中断的最大数量（通常为 32）。</li>
<li>数组索引与枚举值一一对应，例如<code>NET_TX_SOFTIRQ</code>对应的处理函数存储在<code>softirq_vec[NET_TX_SOFTIRQ]</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">    TIMER_SOFTIRQ,</span><br><span class="line">    NET_TX_SOFTIRQ,</span><br><span class="line">    NET_RX_SOFTIRQ,</span><br><span class="line">    BLOCK_SOFTIRQ,</span><br><span class="line">    BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">    TASKLET_SOFTIRQ,</span><br><span class="line">    SCHED_SOFTIRQ,</span><br><span class="line">    HRTIMER_SOFTIRQ,</span><br><span class="line">    RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">    NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为什么创建新的软中断时，必须修改枚举类型并添加新的项？</p>
<blockquote>
<ol>
<li><strong>唯一性保证</strong>：<br>每个软中断必须有唯一的编号，枚举类型通过编译器确保不会出现重复值。</li>
<li><strong>静态数组索引</strong>：<br>软中断处理函数数组<code>softirq_vec</code>的索引依赖于枚举值。例如，新添加的软中断<code>MY_NEW_SOFTIRQ</code>必须对应数组中的特定位置。</li>
<li><strong>编译时验证</strong>：<br>通过枚举类型，内核在编译时就能检查软中断编号是否越界或冲突，避免运行时错误。</li>
</ol>
</blockquote>
<p>流程:</p>
<blockquote>
<ol>
<li>注册软中断的函数open_softirq(kernel&#x2F;softirq.c)</li>
</ol>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment">  * 将软中断类型和软中断处理函数加入到软中断序列中</span></span><br><span class="line"><span class="comment">  * @nr                                 - 软中断类型 索引号</span></span><br><span class="line"><span class="comment">  * @(*action)(struct softirq_action *) - 软中断处理的函数指针</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">/* softirq_vec是个struct softirq_action类型的数组 */</span></span><br><span class="line">     softirq_vec[nr].action = action;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当内核运行一个软中断处理程序的时候,他就会执行这个action函数</span></span><br><span class="line"><span class="comment"> * 参数指向相应softirq_action结构体的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_softirq_handler</span><span class="params">(<span class="keyword">struct</span> softirq_action *h)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 软中断处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  struct softirq_action 的定义也在 include&#x2F;linux&#x2F;interrupt.h 文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个结构体的字段是个函数指针，字段名称是action</span></span><br><span class="line"><span class="comment"> * 函数指针的返回指是void型</span></span><br><span class="line"><span class="comment"> * 函数指针的参数是 struct softirq_action 的地址，其实就是指向 softirq_vec 中的某一项</span></span><br><span class="line"><span class="comment"> *     如果 open_softirq 是这样调用的： open_softirq(NET_TX_SOFTIRQ, my_tx_action);</span></span><br><span class="line"><span class="comment"> *     my_tx_action 就是处理函数</span></span><br><span class="line"><span class="comment"> *     那么 my_tx_action 的参数就是 softirq_vec[NET_TX_SOFTIRQ]的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span>    (*action)(<span class="keyword">struct</span> softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>触发软中断 raise_softirq 参见 kernel&#x2F;softirq.c文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 触发某个中断类型的软中断</span></span><br><span class="line"><span class="comment"> * @nr - 被触发的中断类型</span></span><br><span class="line"><span class="comment"> * 从函数中可以看出，在处理软中断前后有保存和恢复寄存器的操作</span></span><br><span class="line"><span class="comment"> * 触发软中断前 “禁止中断” 是为了保证 pending 位图修改的原子性，避免并发场景下的竞态和数据不一致；而 “恢复状态” 是为了最小化对系统中断响应的影响，确保其他中断能正常处理。这一机制是内核在 “安全性” 和 “实时性” 之间的平衡设计，既保护了软中断触发的可靠性，又避免了过度屏蔽中断导致的系统性能下降。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    local_irq_save(flags);  <span class="comment">// 保存当前中断状态,并静止中断.</span></span><br><span class="line">    raise_softirq_irqoff(nr);</span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq_irqoff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span> &#123;</span><br><span class="line">    __raise_softirq_irqoff(nr);</span><br><span class="line">    <span class="keyword">if</span> (!in_interrupt())</span><br><span class="line">        wakeup_softirqd(); <span class="comment">// 唤醒软中断内核线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过设置pending位图（每个 CPU 一个）标记软中断待处理。</span></span><br><span class="line"><span class="comment"> * 若当前不在中断上下文，唤醒ksoftirqd内核线程处理软中断。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行软中断 do_softirq </p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> <span class="title function_">do_softirq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    __u32 pending;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断是否在中断处理中，如果正在中断处理，就直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (in_interrupt())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 保存当前寄存器的值 */</span></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 取得当前已注册软中断的位图 */</span></span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 循环处理所有已注册的软中断 */</span></span><br><span class="line">    <span class="keyword">if</span> (pending)</span><br><span class="line">        __do_softirq();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复寄存器的值到中断处理前 */</span></span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asmlinkage <span class="type">void</span> __do_softirq(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pending;</span><br><span class="line">    <span class="type">int</span> max_restart = MAX_SOFTIRQ_RESTART; <span class="comment">// 默认10次</span></span><br><span class="line">    <span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">    pending = local_softirq_pending(); <span class="comment">// 获取待处理软中断位图</span></span><br><span class="line">    account_system_vtime(current);</span><br><span class="line">    __local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);</span><br><span class="line">    lockdep_softirq_enter();</span><br><span class="line"></span><br><span class="line">    cpu = smp_processor_id();</span><br><span class="line">restart:</span><br><span class="line">    <span class="comment">/* Reset the pending bitmask before enabling irqs */</span></span><br><span class="line">    set_softirq_pending(<span class="number">0</span>); <span class="comment">// 清除位图</span></span><br><span class="line"></span><br><span class="line">    local_irq_enable(); <span class="comment">// 开中断，允许嵌套</span></span><br><span class="line"></span><br><span class="line">    h = softirq_vec;</span><br><span class="line">    <span class="keyword">while</span> ((softirq_bit = ffs(pending))) &#123; <span class="comment">// 查找待处理的最高位</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> vec_nr;</span><br><span class="line">        <span class="type">int</span> prev_count;</span><br><span class="line"></span><br><span class="line">        h += softirq_bit - <span class="number">1</span>; <span class="comment">// 定位到对应softirq_action</span></span><br><span class="line">        vec_nr = h - softirq_vec; <span class="comment">// 计算软中断编号</span></span><br><span class="line">        prev_count = preempt_count();</span><br><span class="line"></span><br><span class="line">        kstat_incr_softirqs_this_cpu(vec_nr);</span><br><span class="line"></span><br><span class="line">        trace_softirq_entry(vec_nr);</span><br><span class="line">        h-&gt;action(h); <span class="comment">// 调用处理函数！</span></span><br><span class="line">        trace_softirq_exit(vec_nr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(prev_count != preempt_count())) &#123;</span><br><span class="line">            printk(KERN_ERR <span class="string">&quot;huh, entered softirq %u %s %p&quot;</span></span><br><span class="line">                  <span class="string">&quot;with preempt_count %08x, exited with %08x?\n&quot;</span>,</span><br><span class="line">                  vec_nr, softirq_to_name[vec_nr],</span><br><span class="line">                  h-&gt;action, prev_count, preempt_count());</span><br><span class="line">            preempt_count() = prev_count;</span><br><span class="line">        &#125;</span><br><span class="line">        h++;</span><br><span class="line">        pending &gt;&gt;= softirq_bit; <span class="comment">// 右移，处理下一位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    local_irq_disable(); <span class="comment">// 关中断</span></span><br><span class="line"></span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line">    <span class="keyword">if</span> (pending &amp;&amp; --max_restart)</span><br><span class="line">        <span class="keyword">goto</span> restart; <span class="comment">// 若有新的软中断被触发，且未超过重试次数，继续处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pending)</span><br><span class="line">        wakeup_softirqd(); <span class="comment">// 若仍有待处理，唤醒内核线程</span></span><br><span class="line"></span><br><span class="line">    lockdep_softirq_exit();</span><br><span class="line">    account_system_vtime(current);</span><br><span class="line">    _local_bh_enable(SOFTIRQ_OFFSET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行相应的软中断 - 执行自己写的中断处理</p>
</li>
</ol>
<p>  znelinux中，执行软中断有专门的内核线程，每个处理器对应一个线程，名称ksoftirqd&#x2F;n (n对应处理器号)</p>
</blockquote>
<h4 id="2-2-tasklet"><a href="#2-2-tasklet" class="headerlink" title="2.2 tasklet"></a>2.2 tasklet</h4><p>tasklet也是利用软中断实现的，但是他提供了比软中断更好用的接口（实际就是基于软中断又封装了一下），所以除了对性能要求特别高的情况，一般建议使用tasklet来实现自己的中断。tasklet由两类软中断代表：HI_SOFTIRQ和TASKLET_SOFTIRQ。这两者的唯一区别就是前者优先级高。</p>
<p>tasklet对应的结构体在&lt;linux&#x2F;interrupt.h&gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 每个结构体代表一个 tasklet </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span> <span class="comment">/* 链表中的下一个tasklet */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> state;         <span class="comment">/* tasklet状态 */</span></span><br><span class="line">    <span class="type">atomic_t</span> count;              <span class="comment">/* 引用计数器 */</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">/* tasklet处理函数  和软中断的action一样，*/</span>  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;          <span class="comment">/* tasklet处理函数的参数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>tasklet状态只有3种值：</p>
<ol>
<li>值 0 表示该tasklet没有被调度</li>
<li>值 TASKLET_STATE_SCHED 表示该tasklet已经被调度</li>
<li>值 TASKLET_STATE_RUN 表示该tasklet正在运行</li>
</ol>
<p>引用计数器count 的值不为0，表示该tasklet被禁止，不允许被执行。只有当它为0，tasklet才被激活，并且在被设置为挂起状态时，该taaklet才能够执行。</p>
<p>tasklet的使用流程如下：</p>
<ol>
<li>声明tasklet</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参见linux/interrupt.h</span></span><br><span class="line"><span class="comment"> * 使用宏 静态声明一个tasklet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET(name, func, data) \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment">// 这段代码等价于</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">name</span> =</span> &#123; <span class="literal">NULL</span>, <span class="number">0</span>, ATOMIC_INIT(<span class="number">0</span>), func, data &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET_DISABLED(name, func, data) \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment">/*动态声明一个tasklet 传递一个tasklet_struct指针给初始化函数*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tasklet_init</span> <span class="params">(<span class="keyword">struct</span> tasklet_struct *t,</span></span><br><span class="line"><span class="params">             <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tasklet_init</span><span class="params">(t , tasklet_handler, dev)</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写处理程序</li>
</ol>
<p>参照tasklet处理函数的原型来写自己的处理逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_handler</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调度tasklet</li>
</ol>
<p>中断的上半部分处理完后调度tasklet，在适当时候进行下半部的处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklet_schedule(&amp;my_tasklet) <span class="comment">/* 这里的就是之前声明的，这里将my_tasklet标记为挂起。*/</span></span><br></pre></td></tr></table></figure>

<p>调度的流程：</p>
<h4 id="2-3-工作队列"><a href="#2-3-工作队列" class="headerlink" title="2.3 工作队列"></a>2.3 工作队列</h4><p>工作队列子系统是一个用于创建内核线程的接口，通过它可以创建一个工作者线程来专门处理中断的下半部工作，负责执行由内核其他部分排到队列里的任务。工作队列提供了一个缺省的工作者线程来处理这些工作。叫做events&#x2F;n（n对应处理器号）</p>
<p>工作队列和tasklet不一样，不是基于软中断来实现的。</p>
<p>工作队列主要用到下面三个结构体，弄懂了这三个结构体的关系！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* 在 include/linux/workqueue.h 文件中定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span> data;             <span class="comment">/* 这个并不是处理函数的参数，而是表示此work是否pending等状态的flag */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORK_STRUCT_PENDING 0        <span class="comment">/* T if work item pending execution */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORK_STRUCT_FLAG_MASK (3UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORK_STRUCT_WQ_DATA_MASK (~WORK_STRUCT_FLAG_MASK)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span>         <span class="comment">/* 中断下半部处理函数的链表 */</span></span><br><span class="line">    <span class="type">work_func_t</span> func;               <span class="comment">/* 处理中断下半部工作的函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 kernel/workqueue.c文件中定义</span></span><br><span class="line"><span class="comment"> * 每个工作者线程对应一个 cpu_workqueue_struct ，其中包含要处理的工作的链表</span></span><br><span class="line"><span class="comment"> * (即 work_struct 的链表，当此链表不空时，唤醒工作者线程来进行处理)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The per-CPU workqueue (if single thread, we always use the first</span></span><br><span class="line"><span class="comment"> * possible cpu).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">spinlock_t</span> lock;                   <span class="comment">/* 锁保护这种结构 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">worklist</span>;</span>         <span class="comment">/* 工作队列头节点 */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> more_work;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">current_work</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span>       <span class="comment">/* 关联工作队列结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span>;</span>        <span class="comment">/* 关联线程 */</span></span><br><span class="line">&#125; ____cacheline_aligned;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 也是在 kernel/workqueue.c 文件中定义的</span></span><br><span class="line"><span class="comment"> * 每个 workqueue_struct 表示一种工作者类型，系统默认的就是 events 工作者类型</span></span><br><span class="line"><span class="comment"> * 每个工作者类型一般对应n个工作者线程，n就是处理器的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The externally visible workqueue abstraction is an array of</span></span><br><span class="line"><span class="comment"> * per-CPU workqueues:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> *<span class="title">cpu_wq</span>;</span>  <span class="comment">/* 工作者线程 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> singlethread;</span><br><span class="line">    <span class="type">int</span> freezeable;        <span class="comment">/* Freeze threads during suspend */</span></span><br><span class="line">    <span class="type">int</span> rt;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用工作队列</li>
</ul>
<h2 id="第十二章-内存管理"><a href="#第十二章-内存管理" class="headerlink" title="第十二章 内存管理"></a>第十二章 内存管理</h2><h3 id="1-1-页和区"><a href="#1-1-页和区" class="headerlink" title="1.1 页和区"></a>1.1 页和区</h3><p>在内核中把物理页作为内存管理的基本单位。页的大小根据体系结构不同大小不同，32就是4KB，64位就是8KB，使用一个page结构体来表示系统中的每个页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>			flags;  <span class="comment">// 存放页的状态 可以至少同时表示出32种不同的状态</span></span><br><span class="line">   	<span class="type">atomic_t</span>				_count; <span class="comment">// 页的引用计数，为-1的时候表示内核没有引用这一页，在新的分配中可以使用它，内核调用page_count(struct page)来返回0表示这是个空闲页。</span></span><br><span class="line">    <span class="type">atomic_t</span>				_mapcount; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>			private; <span class="comment">//私有数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">mapping</span>;</span> <span class="comment">//指向和这个页相关联address_space 对象</span></span><br><span class="line">    <span class="type">pgoff_t</span>					index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">lru</span>;</span></span><br><span class="line">    <span class="type">void</span>					*virtual; <span class="comment">//页的虚拟地址，高端内存的动态映射地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核仅用这个数据来描述当前在相关物理页种存放的东西，目的在于描述物理页本身，即页是否被分配，谁拥有这个页等等。</p>
<p>区是为了在有限的虚拟地址空间里，既让内核安全高效的访问所有物理内存，又兼顾dma、性能、碎片和硬件限制的设计。</p>
<p>在32位的机器中，Linux 把 4 GB 虚拟地址空间切成两段：</p>
<ul>
<li>0–3 GB：用户进程</li>
<li>3–4 GB：内核固定映射（对所有进程相同）</li>
</ul>
<p>内核又把这 1 GB 继续细分为几个“内存域（zone）：</p>
<table>
<thead>
<tr>
<th align="left">区域</th>
<th align="left">物理地址范围</th>
<th align="left">虚拟地址范围</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>ZONE_DMA</strong></td>
<td align="left">0–16 MB</td>
<td align="left">3 GB+0–16 MB</td>
<td align="left">ISA 老设备 DMA 只能访问低 16 MB</td>
</tr>
<tr>
<td align="left"><strong>ZONE_NORMAL</strong></td>
<td align="left">16 MB–896 MB</td>
<td align="left">3 GB+16 MB–896 MB</td>
<td align="left">直接映射区，kmalloc() 大多数分配在这里，可以快速找到</td>
</tr>
<tr>
<td align="left"><strong>ZONE_HIGHMEM</strong></td>
<td align="left">896 MB–4 GB</td>
<td align="left">3 GB+896 MB 以上</td>
<td align="left">高端内存，不能永久映射到内核地址空间，只有在需要时临时映射</td>
</tr>
</tbody></table>
<p>linux把系统的页划分为区，形成不同的内存池，这样可以按照用途来分配，分配是不可以跨区的。区的划分没有物理意义，是内核为了管理页采取的逻辑上的分组。</p>
<p>在64位的体系结构中，如x86-64 给内核预留了 128 TB 虚拟地址，足够线性映射 64 TB 物理内存，不再需要 HIGHMEM，只剩下 ZONE_DMA &#x2F; ZONE_NORMAL。</p>
<p>内核通过区和页这种机制来管理内存。</p>
<h3 id="1-2-获得内存"><a href="#1-2-获得内存" class="headerlink" title="1.2 获得内存"></a>1.2 获得内存</h3><ul>
<li><p>获取页</p>
<p>主要是几个请求内存的接口，以页为单位：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">场景 &#x2F; 需求</th>
<th align="left">函数（宏）原型</th>
<th align="left">获得什么</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">分配 2^order  个连续页</td>
<td align="left"><code>struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)</code></td>
<td align="left">首 page 指针</td>
<td align="left">最常用底层接口</td>
</tr>
<tr>
<td align="left">只拿 1 页</td>
<td align="left"><code>#define alloc_page(gfp) alloc_pages(gfp, 0)</code></td>
<td align="left">同上</td>
<td align="left">宏</td>
</tr>
<tr>
<td align="left">拿页并返回虚拟地址</td>
<td align="left"><code>unsigned long __get_free_pages(gfp_t gfp, unsigned int order)</code></td>
<td align="left">逻辑地址的指针</td>
<td align="left">内部仍用 alloc_pages，再 page_address</td>
</tr>
<tr>
<td align="left">同上，只拿 1 页</td>
<td align="left"><code>#define __get_free_page(gfp) __get_free_pages(gfp, 0)</code></td>
<td align="left">同上</td>
<td align="left">宏</td>
</tr>
<tr>
<td align="left">拿 1 页并清零</td>
<td align="left"><code>unsigned long get_zeroed_page(gfp_t gfp)</code></td>
<td align="left">逻辑地址的指针</td>
<td align="left">含 <code>__GFP_ZERO</code></td>
</tr>
<tr>
<td align="left">释放 page 描述符</td>
<td align="left"><code>void __free_pages(struct page *page, unsigned int order)</code></td>
<td align="left">-</td>
<td align="left">与 alloc_pages 成对</td>
</tr>
<tr>
<td align="left">释放线性地址</td>
<td align="left"><code>void free_pages(unsigned long addr, unsigned int order)</code></td>
<td align="left">-</td>
<td align="left">与 __get_free_pages 成对</td>
</tr>
</tbody></table>
<p>在获得内存后要进行错误检查，可能会分配失败的。</p>
<ul>
<li>小对象，以字节为单位的内存申请，物理连续</li>
</ul>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">函数原型</th>
<th align="left">获得什么</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">通用小对象</td>
<td align="left"><code>void *kmalloc(size_t size, gfp_t gfp)</code></td>
<td align="left">内存块的指针</td>
<td align="left">&lt; 4 MB，最常用</td>
</tr>
<tr>
<td align="left">清零版本</td>
<td align="left"><code>void *kzalloc(size_t size, gfp_t gfp)</code></td>
<td align="left">同上</td>
<td align="left">kmalloc + memset 0</td>
</tr>
<tr>
<td align="left">大数组</td>
<td align="left"><code>void *kcalloc(size_t n, size_t size, gfp_t gfp)</code></td>
<td align="left">同上</td>
<td align="left">kzalloc 的数组封装</td>
</tr>
<tr>
<td align="left">释放</td>
<td align="left"><code>void kfree(void *ptr)</code></td>
<td align="left">-</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>注意检查分配是否成功，返回的是不是null</p>
<ul>
<li>vmalloc()</li>
</ul>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">函数原型</th>
<th align="left">获得什么</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">任意大小，虚拟连续</td>
<td align="left"><code>void *vmalloc(unsigned long size)</code></td>
<td align="left">内核虚拟地址</td>
<td align="left">可能睡眠，不能用于 DMA</td>
</tr>
<tr>
<td align="left">释放</td>
<td align="left"><code>void vfree(const void *addr)</code></td>
<td align="left">-</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>大多数情况下，只有硬件设备需要得到物理连续的地址。但是内核使用kmalloc性能好，vmalloc需要一个个的映射，建立页表项，</p>
<ul>
<li>gfp_mask标志</li>
</ul>
<p>在以上接口中，我们都能发现，它用到了一个参数<code>gfp_t gfp_mask</code> ，这个参数是一个分配器的标志，可以理解为内核把“怎么拿页”抽象成了gfp_mask这样的一个位图。包括从哪里拿？拿的时候能干吗？即区修饰符，行为修饰符。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">常用位</th>
<th align="left">作用一句话</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>区修饰符</strong></td>
<td align="left"><code>__GFP_DMA</code>、<code>__GFP_DMA32</code>、<code>__GFP_HIGHMEM</code></td>
<td align="left">限定从 ZONE_DMA &#x2F; DMA32 &#x2F; HIGHMEM 拿页，默认从zone_normal区分配。不能给_get_free_pages()和kalloc()指定高端内存，他们返回的是逻辑地址而不是page结构，分配的这个页可能还没有映射到虚拟空间上。</td>
</tr>
<tr>
<td align="left"><strong>行为修饰符</strong></td>
<td align="left"><code>__GFP_IO</code>、<code>__GFP_FS</code>、<code>__GFP_WAIT</code>、<code>__GFP_COLD</code>、<code>__GFP_ZERO</code>、<code>__GFP_NOWARN</code> 等</td>
<td align="left">能否启磁盘 I&#x2F;O、能否启文件系统 I&#x2F;O、能否睡眠、是否应该使用高速缓存中快要淘汰出的页、是否清零、是否不打印失败警告</td>
</tr>
</tbody></table>
<p>类型标志则是行为和区描述符的组合，来完成特殊类型的处理。一般用这个就行了。</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>隐含的位</th>
<th>典型场景</th>
<th>能否阻塞</th>
</tr>
</thead>
<tbody><tr>
<td><code>GFP_KERNEL</code></td>
<td><code>__GFP_WAIT | __GFP_IO | __GFP_FS</code></td>
<td>普通进程上下文</td>
<td>✅</td>
</tr>
<tr>
<td><code>GFP_ATOMIC</code></td>
<td><code>__GFP_HIGH | __GFP_ATOMIC</code></td>
<td>中断、持有 spinlock（不可睡眠）</td>
<td>❌</td>
</tr>
<tr>
<td><code>GFP_NOIO</code></td>
<td><code>__GFP_WAIT</code>（但无 <code>__GFP_IO</code>）</td>
<td>块层、不会启动磁盘I&#x2F;O不能递归 I&#x2F;O</td>
<td>✅</td>
</tr>
<tr>
<td><code>GFP_NOFS</code></td>
<td><code>__GFP_WAIT | __GFP_IO</code>（无 <code>__GFP_FS</code>）</td>
<td>文件系统内部</td>
<td>✅</td>
</tr>
<tr>
<td><code>GFP_USER</code></td>
<td>同 <code>GFP_KERNEL</code></td>
<td>给用户态进程页缓存</td>
<td>✅</td>
</tr>
<tr>
<td><code>GFP_HIGHUSER</code></td>
<td><code>GFP_USER | __GFP_HIGHMEM</code></td>
<td>用户态页，优先 HIGHMEM</td>
<td>✅</td>
</tr>
<tr>
<td><code>GFP_HIGHUSER_MOVABLE</code></td>
<td><code>GFP_HIGHUSER</code> + 可迁移属性</td>
<td>匿名页、可压缩&#x2F;迁移</td>
<td>✅</td>
</tr>
<tr>
<td><code>GFP_DMA</code></td>
<td><code>__GFP_DMA</code></td>
<td>ISA 设备 DMA，通常与上面某个标志组合使用</td>
<td>✅&#x2F;❌</td>
</tr>
<tr>
<td><code>GFP_DMA32</code></td>
<td><code>__GFP_DMA32</code></td>
<td>32 位总线设备</td>
<td>✅&#x2F;❌</td>
</tr>
</tbody></table>
<p>什么时候使用哪种标志：</p>
<p>普通内核数据结构		 GFP_KERNEL<br>中断 &#x2F; 自旋锁内  		   GFP_ATOMIC<br>文件系统内部       	 	GFP_NOFS<br>块层 I&#x2F;O 路径        		GFP_NOIO<br>用户态页缓存        		GFP_USER &#x2F; GFP_HIGHUSER_MOVABLE<br>DMA内存可以睡眠		GFP_DMA|GFP_KERNEL</p>
<h3 id="1-3-使用页"><a href="#1-3-使用页" class="headerlink" title="1.3 使用页"></a>1.3 使用页</h3><p>​	从上面我们知道了怎么从内存中获得页,但对于程序的数据结构来说,一个页的粒度还是太大了,用不了那么多啊,总不能随便一个数据结构就用一页,那多浪费,又产生大量碎片,怎么办呢?那就继续细分!<br>​	在内核中,分配和释放数据结构是内核中最普遍的操作,为了便于数据的频繁分配和回收,内核的开发人员经常会用到空闲链表,空闲链表里装着已经分配好的数据结构块,当我们需要的时候就从空闲链表抓一个数据块,把我们的数据塞进去.不用的时候再放回空闲链表(并不释放).这样空闲链表就相当于对象高速缓存(快速存储频繁使用的对象类型).</p>
<p>​	空闲链表虽便于数据结构的频繁分配和回收，但面临不能全局控制的问题，内核无法在内存紧张时通知其收缩缓存大小以释放内存，且内核不知其存在。</p>
<p>​	空闲链表也有缺陷,那继续修复.slab层应运而生.slab分配器就扮演了通用数据结构缓存层的角色.我们用slab层在页之上,再做一级对象级的内存管理.</p>
<p>​	slab分配器的设计原则- <strong>缓存频繁使用的数据结构</strong>：频繁分配和释放的数据结构应被缓存，以提高性能。- <strong>避免内存碎片</strong>：空闲链表的缓存连续存放，防止内存碎片化.</p>
<p>​	那么slab是怎么设计的呢?</p>
<ul>
<li><ul>
<li>slab的设计</li>
</ul>
</li>
</ul>
<p>​	slab层把不同的对象划分为所谓的高速缓存组,其中的每个高速缓存组都存放着不同类型的对象.而每种对象类型,对应一个高速缓存.在内核中,我们把这个高速缓存称作<code>kmem_cache</code> .他用来专门存放一种对象.一种内核数据结构（如 <code>task_struct</code>、<code>inode</code>、<code>dentry</code> 等）对应一个 <strong>kmem_cache</strong>.</p>
<p>​	然后,这些高速缓存又被分为了slab.每个 slab 是 <strong>一个或多个连续物理页</strong>（通常是 1、2、4、8 页，按 2ⁿ 对齐），内部切成固定数量的 <strong>对象槽位</strong>。每个slab都包含一些对象成员,,就是被缓存的数据结构.</p>
<p>slab 有三种状态：</p>
<blockquote>
<p> <strong>empty</strong>：所有槽位空闲；系统内存紧张时可以被整页回收。<br> <strong>partial</strong>：部分已分配，部分空闲；<strong>分配优先从这里拿</strong>，避免创建新 slab。<br> <strong>full</strong>：已全部用完；不再参与分配，直到有对象被释放回来。</p>
</blockquote>
<p>​	每个slab被划分为许多对象槽.这些槽位是真正返给调用者的那块对齐内存；大小由 kmem_cache 决定，通常是 32、64、128、…、8192 字节档.</p>
<p>​	分配时：slab 层直接把一个对象槽位从链表里摘掉；</p>
<p>​	释放时：把对象放回所属 slab，并立刻合并到空闲链表中，O(1) 完成。</p>
<p>可以将这个抽象为一个小抽屉:</p>
<p>┌──────────────────────────┐<br>│ 抽屉柜：kmem_cache       │  ← 一种对象类型一个柜子<br>│                          │<br>│  ┌────────────────────┐  │<br>│  │ 抽屉：slab         │  ← 一个&#x2F;多个连续物理页<br>│  │                    │  │<br>│  │ ┌──┐ ┌──┐ ┌──┐    │  │<br>│  │ │obj││obj││obj│ … │ │  ← 真正可用的对象实例<br>│  │ └──┘ └──┘ └──┘    │  │<br>│  └────────────────────┘  │<br>│  ┌────────────────────┐  │<br>│  │ 抽屉：slab         │  │<br>│  └────────────────────┘  │<br>│  …                       │<br>└──────────────────────────┘</p>
<p>​		</p>
<p>​	上面说了一些理论知识的理解，我们再来看一些代码相关的。我们自上而下的从抽屉柜（高速缓存）kmem_cache来看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 对象属性 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        object_size;    <span class="comment">/* 用户请求的对象大小 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        size;           <span class="comment">/* 对齐/填充后真正占用空间 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        align;          <span class="comment">/* 对齐边界 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        min_partial;    <span class="comment">/* per-node partial 链表最少保留 slab 数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配/释放钩子 */</span></span><br><span class="line">    <span class="type">void</span>               (*ctor)(<span class="type">void</span> *); <span class="comment">/* 对象构造函数（如初始化锁） */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>         *name;           <span class="comment">/* 人类可读名字，/proc/slabinfo 可见 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* slab 管理参数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        oo;             <span class="comment">/* oo = (order &lt;&lt; 16) | objects</span></span><br><span class="line"><span class="comment">                                           - order: 本 cache 一个 slab 占 2^order 页</span></span><br><span class="line"><span class="comment">                                           - objects: 该 slab 可容纳对象数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        min;            <span class="comment">/* 最小 slab 阶数（内存紧张时降级） */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CPU 与节点级缓存 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span> <span class="comment">/* per-CPU 数据结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span> <span class="comment">/* per-NUMA-node 结构数组 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调试与安全 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       random;         <span class="comment">/* 每次启动随机值，用于指针哈希 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 其余字段：list_head list; (所有 kmem_cache 全局链表) 等 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*来自kimi的5.18+内核的slub_def.h中的简化视图*/</span></span><br></pre></td></tr></table></figure>

<p>​	从结构体内中我们可以看出kmem_cache为某一种专用的对象类型服务，用来统管<strong>某一种固定大小对象的分配</strong>，结构体的定义在创建阶段就将对象的大小，以及摆放规则划分好。他管理着更下一层的slab，包含着满，半满，空三个数据链表。</p>
<p>​	再来看看slab。slab描述符struct slab 用来描述每个slab。现在的slab描述符和page复用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span>                 <span class="comment">/* 与 struct page 共用内存 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span>   <span class="comment">/* 指向所属的 cache */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab</span>       *<span class="title">next</span>;</span>         <span class="comment">/* per-CPU 单向链表指针 */</span></span><br><span class="line">    <span class="type">int</span>               slabs;         <span class="comment">/* 本链表中剩余 slab 数（per-CPU 列表用） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">slab_list</span>;</span>     <span class="comment">/* per-node 双向链表节点 */</span></span><br><span class="line">    <span class="type">void</span>              *freelist;     <span class="comment">/* 指向本 slab 内第一个空闲对象 */</span></span><br><span class="line">    <span class="comment">/* 其余 page 字段被复用/隐藏 */</span></span><br><span class="line">&#125;;<span class="comment">//这里和2.6有很多不同了，但是思想上还是大体一致。</span></span><br></pre></td></tr></table></figure>

<p>​	对象就是一个个简单的结构体就不细述了。</p>
<h3 id="1-5-slab分配器的接口"><a href="#1-5-slab分配器的接口" class="headerlink" title="1.5 slab分配器的接口"></a>1.5 slab分配器的接口</h3><p>创建销毁：</p>
<table>
<thead>
<tr>
<th>kmem_cache_create()</th>
<th><code>struct kmem_cache *kmem_cache_create(const char *name, size_t size, size_t align, unsigned flags, void (*ctor)(void *));</code></th>
<th>给某一类对象建专用高速缓存；返回的指针就是“cache 句柄”。</th>
</tr>
</thead>
<tbody><tr>
<td>kmem_cache_create_usercopy()</td>
<td>同上，多两个参数 <code>useroffset, usersize</code></td>
<td>若对象里包含用户可拷贝区域，需用此版本以便 hardened usercopy 检查。</td>
</tr>
<tr>
<td>kmem_cache_destroy()</td>
<td><code>void kmem_cache_destroy(struct kmem_cache *s);</code></td>
<td>卸载模块时销毁；必须保证所有 slab 已空闲，否则返回 <code>-EBUSY</code>。</td>
</tr>
<tr>
<td>kmem_cache_shrink()</td>
<td><code>int kmem_cache_shrink(struct kmem_cache *s);</code></td>
<td>主动把空闲 slab 还给伙伴系统，返回值是“已释放页数”。</td>
</tr>
</tbody></table>
<p>分配释放：</p>
<table>
<thead>
<tr>
<th>kmem_cache_alloc()</th>
<th><code>void *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags);</code></th>
<th>从指定 cache 拿对象；gfpflags 同 kmalloc。</th>
</tr>
</thead>
<tbody><tr>
<td>kmem_cache_zalloc()</td>
<td><code>void *kmem_cache_zalloc(struct kmem_cache *s, gfp_t gfpflags);</code></td>
<td>同上但自动清零。</td>
</tr>
<tr>
<td>kmem_cache_free()</td>
<td><code>void kmem_cache_free(struct kmem_cache *s, void *obj);</code></td>
<td>把对象放回所属 cache；必须配对，不能 kfree。</td>
</tr>
<tr>
<td>kmem_cache_alloc_bulk()</td>
<td><code>int kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t gfp, size_t nr, void **objs);</code></td>
<td>一次拿多个对象，减少 per-CPU 链表锁操作。</td>
</tr>
<tr>
<td>kmem_cache_free_bulk()</td>
<td><code>void kmem_cache_free_bulk(struct kmem_cache *s, size_t nr, void **objs);</code></td>
<td>对应批量释放。</td>
</tr>
</tbody></table>
<p><code>kmem_cache_create()</code> 只是把“对象规格、对齐、构造&#x2F;析构钩子、per-CPU 与 per-node 管理结构”准备好，<strong>并没有真正去向伙伴系统拿页</strong>、也没有生成任何 slab。</p>
<p>第一次真正需要内存时（即第一次调用 <code>kmem_cache_alloc()</code> 且发现 freelist 为空）才会触发。</p>
<p>分配器2.6中和现代内核差距不小，后面再看。</p>
<p>2.6内核中，获得一个slab的内存是底层调用用<code>kmem_getpages(strcut kmem_cahce * cachep,gfp_t flags,int nodeid)</code>这个函数函数来实现的，而这个用的是<code>__get_free_pages()</code>低级内核页分配器进行的。</p>

    </div>

    
    
    

     
   <div>
     <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
   </div>
 
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>gb
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2025/08/02/Linux%20%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="">http://example.com/2025/08/02/Linux 内核设计与实现/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/08/02/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/08/05/LDD3%20%E6%9E%84%E9%80%A0%E5%92%8C%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%9D%97/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.</span> <span class="nav-text">Linux 内核设计与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">第三章 进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">3.1进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.2.</span> <span class="nav-text">3.2 进程描述符和任务结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.1.3.</span> <span class="nav-text">3.3 进程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%B6%E6%97%8F%E6%95%B0"><span class="nav-number">1.1.4.</span> <span class="nav-text">3.4 进程的家族数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.1.5.</span> <span class="nav-text">3.5 进程的创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">1.2.</span> <span class="nav-text">第四章 进程调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">第七章 中断处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86%E5%92%8C%E6%8E%A8%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.4.</span> <span class="nav-text">第八章 下半部分和推后执行的工作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%A4%84%E7%90%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 中断下半部处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. 实现中断下半部的机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">2.1 软中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-tasklet"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">2.2 tasklet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">2.3 工作队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">第十二章 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E9%A1%B5%E5%92%8C%E5%8C%BA"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.1 页和区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%8E%B7%E5%BE%97%E5%86%85%E5%AD%98"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.2 获得内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%BD%BF%E7%94%A8%E9%A1%B5"><span class="nav-number">1.5.3.</span> <span class="nav-text">1.3 使用页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-slab%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.5.4.</span> <span class="nav-text">1.5 slab分配器的接口</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gb"
      src="/images/20210404011504_4219e.png">
  <p class="site-author-name" itemprop="name">gb</p>
  <div class="site-description" itemprop="description">路漫漫其修远兮</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2025-07 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gb</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">25k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">22 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
