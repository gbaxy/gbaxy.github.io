<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Linux 内核设计与实现">
<meta property="og:type" content="article">
<meta property="og:title" content="Studio Blog">
<meta property="og:url" content="http://example.com/2025/08/02/Linux%20%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Studio Blog">
<meta property="og:description" content="Linux 内核设计与实现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\ASUS\Documents\%E7%AC%94%E8%AE%B0\19113723-21463cd0f94f455480d282ac1b38138d.png">
<meta property="og:image" content="c:\Users\ASUS\Documents\%E7%AC%94%E8%AE%B0\23111716-dc0f4c90540c48569dd18f835b2d8af9.png">
<meta property="article:published_time" content="2025-08-02T08:19:38.980Z">
<meta property="article:modified_time" content="2025-08-02T08:39:40.269Z">
<meta property="article:author" content="gb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\ASUS\Documents\%E7%AC%94%E8%AE%B0\19113723-21463cd0f94f455480d282ac1b38138d.png">

<link rel="canonical" href="http://example.com/2025/08/02/Linux%20%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | Studio Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Studio Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/02/Linux%20%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/20210404011504_4219e.png">
      <meta itemprop="name" content="gb">
      <meta itemprop="description" content="路漫漫其修远兮">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Studio Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-08-02 16:19:38 / 修改时间：16:39:40" itemprop="dateCreated datePublished" datetime="2025-08-02T16:19:38+08:00">2025-08-02</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Linux-内核设计与实现"><a href="#Linux-内核设计与实现" class="headerlink" title="Linux 内核设计与实现"></a>Linux 内核设计与实现</h1> <span id="more"></span>

<h2 id="第三章-进程管理"><a href="#第三章-进程管理" class="headerlink" title="第三章 进程管理"></a>第三章 进程管理</h2><p> 主要讲了进程相关。什么是进程？进程描述及结构，如何创建进程？</p>
<h3 id="3-1进程"><a href="#3-1进程" class="headerlink" title="3.1进程"></a>3.1进程</h3><ul>
<li>进程是什么？<blockquote>
<p>进程是执行期的程序以及它所使用的资源的总称。</p>
</blockquote>
</li>
<li>线程是什么？<blockquote>
<p>进程中的活动对象，执行单位。每个线程都有独立的程序计数器，进程栈和一组进程寄存器，共享进程的资源。内核调度的对象是线程。对linux来说，线程是一种特殊的进程。</p>
</blockquote>
</li>
</ul>
<h3 id="3-2-进程描述符和任务结构"><a href="#3-2-进程描述符和任务结构" class="headerlink" title="3.2 进程描述符和任务结构"></a>3.2 进程描述符和任务结构</h3><p>内核把进程的列表存放在任务列表的双向循环链表中。表中的每一项都是<code>task_struct</code>，进程描述符，用来管理一个进程，包含管理进程的所有信息。包含的数据能够描述一个正在执行的程序。如进程打开的文件，状态，地址空间等等。<br>通过slab分配器分配<code>task_struct</code>结构。一般放到栈的最后。 </p>
<p>在内核中 一般用宏<code>current</code>查找到正在运行进程的进程描述符。</p>
<h3 id="3-3-进程的状态"><a href="#3-3-进程的状态" class="headerlink" title="3.3 进程的状态"></a>3.3 进程的状态</h3><p>运行 可中断 不可中断 trace追踪 停止。</p>
<p>内核使用<code>set_task_state(task,state)</code>函数来调整进程的状态。</p>
<h3 id="3-4-进程的家族数"><a href="#3-4-进程的家族数" class="headerlink" title="3.4 进程的家族数"></a>3.4 进程的家族数</h3><p>所有的linux进程，都是init进程的后代。linux中每个进程必有一个父进程和若干个子进程。其关系置于进程描述符中，包含一个指向父进程的task_struct的parent指针，和称为children 的<strong>子进程链表</strong></p>
<h3 id="3-5-进程的创建"><a href="#3-5-进程的创建" class="headerlink" title="3.5 进程的创建"></a>3.5 进程的创建</h3><p>unix采用独特的进程创建方式，使用两个系统调用创建进程，读取可执行文件。<strong>frok()拷贝当前进程创建一个子进程，此时子进程和父进程的区别只在于pid和某些资源与统计量。然后执行exec函数负责读取可执行文件将其装入地址空间开始运行。</strong></p>
<p>frok()使用了一种<strong>写时拷贝</strong>的技术。不复制整个进程地址空间，而是父子共享。在需要写入的时候，才复制，从而使各个进程各自用于各自的拷贝。（ 疑惑？父进程写入的时候子进程也拷贝吗？）</p>
<ol>
<li>首先调用dup_task_struct为新进程创建内核栈，thread_info和task_struct。这些值和当前进程的值一致，且此时进程描述符也是完全相同的。</li>
<li>检查有没有超出用户最大的的进程资源数量。</li>
</ol>
<h2 id="第四章-进程调度"><a href="#第四章-进程调度" class="headerlink" title="第四章 进程调度"></a>第四章 进程调度</h2><p>绝大多数可以在内核之旅的读书笔记上看，这里只做自己不理解的比较细节的问题的解答，及上面没有的补充。</p>
<ul>
<li><p>进程也可以分类，io消耗型和处理器消耗型，但这两者并不互斥。</p>
</li>
<li><p>两种调度优先级，一种内核的nice值，越小优先级越大，另一种是实时优先级，实时优先级数值越高优先级越高，这两个是互斥的，有nice则无实时优先级。有实时优先级说明是实时进程，实时进程的优先级都高于普通进程。nice值的是普通进程。</p>
<blockquote>
<p>在 Linux 系统中，实时进程是指具有严格时间约束、优先级高于普通进程的特殊进程，其设计目标是确保在指定时间内完成任务，避免因调度延迟导致功能失效。</p>
</blockquote>
</li>
<li><p>首先我们知道CFS是个什么，它是linux的调度器的一个模块，一个调度器类，只调度属于自己范畴的进程，CFS是一个针对<strong>普通进程</strong>的调度器类。对于进程调度，设计为分配给进程一个处理器的使用比例而非固定时间片。这个使用比列是在<strong>调度周期</strong>里的。<strong>调度周期是指 CFS 调度器将 CPU 时间分配给所有可运行进程的总时间长度。在一个调度周期内，每个进程按其权重获得相应的 CPU 时间片。</strong>  <strong>目标延迟是指 CFS 调度器保证的、任意进程等待 CPU 的最大时间上限。当系统中进程数较少时，调度周期会收敛到目标延迟，确保低负载下的响应性</strong> 为了防止进程数量趋于无限，所有任务都获得的使用比和时间都趋于零，会有一个<strong>最小粒度</strong>，用来保证任务进程能获得的时间片的底线。最小粒度是 CFS 调度器中控制时间片下限的关键参数，它通过限制单个进程的最小执行时间，平衡了系统的公平性与切换开销。</p>
</li>
<li><p>什么是虚拟实时？</p>
<blockquote>
<p>虚拟实时是 CFS 调度器为每个进程维护的一个虚拟运行时间，它将物理 CPU 时间根据进程优先级（权重）进行了归一化，CFS使用vruntime变量来记录一个程序到底运行了多长时间以及它还应该再运行多久。<strong>对于vruntime的更新逻辑不太明白，还有加权计算，留待深入了解时再来补写</strong>.</p>
<p>使用update_curr来实时更新当前运行进程的虚拟时间(这个是由系统定时器周期性调用的.)    </p>
<ul>
<li>根据当前进程的<strong>物理执行时间</strong>和<strong>权重</strong>，计算并累加其 vruntime。</li>
<li>公式：<code>Δvruntime = (物理时间 × NICE_0_LOAD) / 进程权重</code></li>
</ul>
</blockquote>
</li>
<li><p>调度时靠红黑树,用一个最最子节点的缓存来选择下一个要调度的进程,选择拥有最小vruntime的进程 </p>
</li>
<li><p>调度器入口是Schedule(),通常都会和一个具体的调度类相关联,也就是说,它会找到一个最高优先级的调度类,调度类要有自己的可运行队列.</p>
</li>
</ul>
<h2 id="第七章-中断处理"><a href="#第七章-中断处理" class="headerlink" title="第七章 中断处理"></a>第七章 中断处理</h2><ol>
<li><p>什么是中断？</p>
<p>中断机制是硬件在需要的时候向CPU发出信号，cpu暂停正在进行的工作，来处理硬件请求的一种机制。</p>
<p>详细点的就是硬件向中断控制器的输入引脚发送一个信号，中断控制器会给cpu发送一个电信号，cpu检测到这个信号，就会停止当前的工作，转而处理中断，此后处理器会通知操作系统已经产生中断，这样，操作系统就可以对这个中断进行处理。</p>
</li>
<li><p>中断处理程序</p>
<p>在相应特定在中断的时候，内核会执行一个函数，该函数叫做中断处理函数。产生中断的每一个设备都有一个相应的中断处理函数。中断处理程序运行在中断上下文中（处理器相应中断所处的特殊执行环境）</p>
<p>中断上下文与进程上下文的对比</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>中断上下文</th>
<th>进程上下文</th>
</tr>
</thead>
<tbody><tr>
<td>所属主体</td>
<td>内核（与 CPU 绑定）</td>
<td>具体用户进程或内核线程</td>
</tr>
<tr>
<td>栈空间</td>
<td>内核固定大小栈（CPU 专属）</td>
<td>进程的用户栈或内核栈（动态大小）</td>
</tr>
<tr>
<td>阻塞操作</td>
<td>不允许（会导致系统问题）</td>
<td>允许（如等待 I&#x2F;O、睡眠）</td>
</tr>
<tr>
<td>执行时间</td>
<td>必须极短（毫秒级内）</td>
<td>可长可短（取决于进程任务）</td>
</tr>
<tr>
<td>内存访问</td>
<td>仅能访问内核空间</td>
<td>可访问用户空间和内核空间</td>
</tr>
<tr>
<td>典型操作</td>
<td>设备数据读取、中断标志清除</td>
<td>进程调度、系统调用、内存管理等</td>
</tr>
</tbody></table>
</li>
<li><p>中断类型</p>
<p>中断一般分为异步中断(一般由硬件引起)和同步中断(一般由处理器本身引起)。</p>
<p>异步中断：CPU处理中断的时间过长，所以先将硬件复位，使硬件可以继续自己的工作，然后在适当时候处理中断请求中耗时的部分。</p>
<p>举个例子：网卡的工作原理</p>
<ol>
<li>网卡收到数据包后，向CPU发出中断信号，请求处理接收到的数据包</li>
<li>CPU将收到的数据包拷贝到内存后，即通知网卡继续工作 （上半部）</li>
<li>至于数据包拷贝至内存后的处理会在适当的时候进行  (下半部)</li>
</ol>
<p>这样做避免了处理数据包时间过长导致网卡接收数据包速度变慢。</p>
<p>同步中断：CPU处理完中断请求的所有工作后才反馈硬件</p>
<p>举个例子：系统异常处理(比如运算中的除0操作)</p>
<ol>
<li>应用程序出现异常后，需要内核来处理</li>
<li>内核调用相应的异常处理函数来处理异常</li>
<li>处理完后终了应用程序或者给出message</li>
</ol>
<p>同步中断应该处理能很快完成的一种中断</p>
</li>
<li><p>中断上半部和下半部</p>
<p>上半部只在硬件中断上下文中运行，实时性要求极高，必须立即执行。特点是执行时间短，只处理最紧急，以避免阻塞其他。执行期间禁止同级或更低优先级的中断，但是可能允许更高优先级的中断。</p>
<p>下半部在非中断上下运行，比如进程上下文，允许延迟执行，可处理耗时任务。处理上半部未完成的较为复杂的任务，如对网络卡接收到的数据包进行详细解析、处理和存储等。</p>
</li>
<li><p>中断相关函数</p>
<p>实现一个中断，主要需要三个函数</p>
<ul>
<li>注册中断的函数</li>
<li>释放中断的函数</li>
<li>中断处理程序的声明</li>
</ul>
<p>5.1 注册中断的函数</p>
<p>位置： &lt;linux&#x2F;interrupt.h&gt; include&#x2F;linux&#x2F;interrupt.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * irg     - 表示要分配的中断号</span></span><br><span class="line"><span class="comment"> * handler - 实际的中断处理程序</span></span><br><span class="line"><span class="comment"> * flags   - 标志位，表示此中断的具有特性</span></span><br><span class="line"><span class="comment"> * name    - 中断设备名称的ASCII 表示，这些会被/proc/irq和/proc/interrupts文件使用</span></span><br><span class="line"><span class="comment"> * dev     - 用于共享中断线，多个中断程序共享一个中断线时(共用一个中断号)，依靠dev来区别各个中断程序</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> * 执行成功：0</span></span><br><span class="line"><span class="comment"> * 执行失败：非0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 分配一条给定的中断线*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">                <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">char</span>* name,</span></span><br><span class="line"><span class="params">                <span class="type">void</span> *dev)</span></span><br></pre></td></tr></table></figure>

<p>5.2 释放中断的函数</p>
<p>定义比较简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev)</span></span><br></pre></td></tr></table></figure>

<p>如果不是共享中断线，则直接删除irq对应的中断线。</p>
<p>如果是共享中断线，则判断此中断处理程序是否中断线上的最后一个中断处理程序，</p>
<p>是最后一个中断处理程序 -&gt; 删除中断线和中断处理程序</p>
<p>不是最后一个中断处理程序 -&gt; 删除中断处理程序</p>
<p>5.3 中断处理程序的声明</p>
<p>声明格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 中断处理程序的声明</span></span><br><span class="line"><span class="comment"> * @irp  - 中断处理程序(即request_irq()中handler)关联的中断号</span></span><br><span class="line"><span class="comment"> * @dev  - 与 request_irq()中的dev一样，表示一个设备的结构体</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> * irqreturn_t -  执行成功：IRQ_HANDLED  执行失败：IRQ_NONE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">intr_handler</span><span class="params">(<span class="type">int</span>, irq, <span class="type">void</span> *dev)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>中断处理机制</p>
<p>中断处理的过程主要涉及函数：</p>
<ul>
<li>do_IRQ 与体系结构有关，对所接收的中断进行应答</li>
<li>handle_IRQ_event 调用中断线上所有中断处理</li>
<li>ret_from_intr 恢复寄存器，将内核恢复到中断前的状态。</li>
</ul>
<p><img src="C:\Users\ASUS\Documents\笔记\19113723-21463cd0f94f455480d282ac1b38138d.png" alt="img"></p>
</li>
</ol>
<blockquote>
<p>1.<strong>中断触发阶段</strong></p>
<ul>
<li><strong>硬件信号</strong>：外部设备（如键盘、网卡、定时器）通过中断控制器（如 8259A 或 APIC）向 CPU 发送中断请求信号（IRQ）。</li>
<li><strong>中断向量号</strong>：每个中断源对应一个唯一的<strong>中断向量号</strong>（如键盘中断为 0x21），用于标识中断类型。</li>
<li><strong>边沿 &#x2F; 电平触发</strong>：中断信号可以是边沿触发（如上升沿）或电平触发（如高电平持续），取决于硬件设计。</li>
</ul>
<ol start="2">
<li><strong>CPU 响应阶段</strong></li>
</ol>
<ul>
<li><strong>检测中断</strong>：CPU 在每条指令执行结束后，检查中断引脚是否有信号。</li>
<li>&#x2F;<strong>保存上下文</strong>：若有中断请求且 CPU 允许响应（IF 标志位为 1），则暂停当前程序，保存<strong>硬件上下文</strong>（如寄存器值、FLAGS 标志、CS:IP 指令指针）到内核栈。</li>
<li><strong>关中断</strong>：响应中断时，CPU 自动清除 IF 标志（CLI 指令），禁止同级或低级中断干扰，确保原子性。</li>
<li><strong>获取中断向量</strong>：根据中断向量号，从<strong>中断向量表</strong>（IVT，实模式）或<strong>中断描述符表</strong>（IDT，保护模式）中查找对应的中断处理程序地址。</li>
</ul>
<ol start="3">
<li><strong>中断处理程序执行阶段</strong></li>
</ol>
<ul>
<li><p><strong>跳转到 ISR</strong>：CPU 将控制权转移到中断服务程序（ISR，Interrupt Service Routine）的入口地址。</p>
</li>
<li><p>中断上下文建立：</p>
</li>
<li><p>保存更多寄存器值到内核栈（如通用寄存器 eax、ebx 等）。</p>
</li>
<li><p>设置内核栈指针，切换到中断处理专用栈（避免与进程栈冲突）。</p>
</li>
<li><p>中断处理分阶段：</p>
</li>
<li><p><strong>上半部（Top Half）</strong>：快速执行紧急任务（如读取设备数据、清除中断标志），通常禁止中断。</p>
</li>
<li><p><strong>下半部（Bottom Half）</strong>：将耗时操作推迟到非关键路径（如数据处理、唤醒等待进程），通过软中断、tasklet 或工作队列实现。</p>
</li>
<li><p><strong>中断返回</strong>：执行 IRET&#x2F;IRETD 指令，恢复硬件上下文（寄存器值、FLAGS、CS:IP），重新开中断（IF 标志恢复）。</p>
</li>
</ul>
<ol start="4">
<li><strong>中断嵌套与优先级</strong></li>
</ol>
<ul>
<li><strong>多级中断</strong>：现代 CPU 支持多级中断优先级（如 x86 的 IRQL 机制），高优先级中断可抢占低优先级中断。</li>
<li><strong>中断屏蔽</strong>：通过设置中断控制器的屏蔽位（如 8259A 的 IMR 寄存器），可选择性屏蔽某些中断源。</li>
</ul>
</blockquote>
<ol start="7">
<li>中断控制的方法</li>
</ol>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>local_irq_disable()</td>
<td>禁止本地中断传递</td>
</tr>
<tr>
<td>local_irq_enable()</td>
<td>激活本地中断传递</td>
</tr>
<tr>
<td>local_irq_save()</td>
<td>保存本地中断传递的当前状态，然后禁止本地中断传递</td>
</tr>
<tr>
<td>local_irq_restore()</td>
<td>恢复本地中断传递到给定的状态</td>
</tr>
<tr>
<td>disable_irq()</td>
<td>禁止给定中断线，并确保该函数返回之前在该中断线上没有处理程序在运行</td>
</tr>
<tr>
<td>disable_irq_nosync()</td>
<td>禁止给定中断线</td>
</tr>
<tr>
<td>enable_irq()</td>
<td>激活给定中断线</td>
</tr>
<tr>
<td>irqs_disabled()</td>
<td>如果本地中断传递被禁止，则返回非0；否则返回0</td>
</tr>
<tr>
<td>in_interrupt()</td>
<td>如果在中断上下文中，则返回非0；如果在进程上下文中，则返回0</td>
</tr>
<tr>
<td>in_irq()</td>
<td>如果当前正在执行中断处理程序，则返回非0；否则返回0</td>
</tr>
</tbody></table>
<h2 id="下半部分和推后执行的工作"><a href="#下半部分和推后执行的工作" class="headerlink" title="下半部分和推后执行的工作"></a>下半部分和推后执行的工作</h2><h3 id="1-中断下半部处理"><a href="#1-中断下半部处理" class="headerlink" title="1. 中断下半部处理"></a><strong>1. 中断下半部处理</strong></h3><p>那么对于一个中断，如何划分上下两部分呢？哪些处理放在上半部，哪些处理放在下半部？</p>
<p>这里有一些经验可供借鉴：</p>
<ol>
<li>如果一个任务对时间十分敏感，将其放在上半部</li>
<li>如果一个任务和硬件有关，将其放在上半部</li>
<li>如果一个任务要保证不被其他中断打断，将其放在上半部</li>
<li>其他所有任务，考虑放在下半部</li>
</ol>
<p>上半部分完成绝对中断的及时相应，比如操作硬件对中断的到达确认，从硬件中拷贝数据。</p>
<p>下半部的任务就是执行和中断处理密切相关但中断处理程序本身不执行的工作。</p>
<h3 id="2-实现中断下半部的机制"><a href="#2-实现中断下半部的机制" class="headerlink" title="2. 实现中断下半部的机制"></a><strong>2. 实现中断下半部的机制</strong></h3><p>实现下半部的方法很多，随着内核的发展，产生了一些新的方法，也淘汰了一些旧方法。</p>
<p>目前使用最多的是以下3种方法</p>
<ul>
<li>2.1 软中断</li>
<li>2.2 tasklet</li>
<li>2.3 工作队列</li>
</ul>
<h4 id="2-1-软中断"><a href="#2-1-软中断" class="headerlink" title="2.1 软中断"></a>2.1 软中断</h4><p>软中断是子啊编译期间静态分配的。</p>
<p>其流程如图所示：</p>
<p><img src="C:\Users\ASUS\Documents\笔记\23111716-dc0f4c90540c48569dd18f835b2d8af9.png" alt="23111716-dc0f4c90540c48569dd18f835b2d8af9.png (543×358)"></p>
<p>在编译期间，有个枚举类型静态声明软中断，内核用这些从0开始的索引标识一种相对优先级。索引号小的软中断在索引号大的软中断之前执行。软中断类型通过<code>enum</code>枚举定义，每个枚举值对应一个唯一的软中断编号。例如，在<code>include/linux/interrupt.h</code>中：建立一个新的软中断必须在此枚举类型种加入新的项。</p>
<p>内核维护一个全局数组<code>softirq_vec</code>，每个数组元素对应一个软中断处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>] __<span class="title">cacheline_aligned_in_smp</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>NR_SOFTIRQS</code>表示软中断的最大数量（通常为 32）。</li>
<li>数组索引与枚举值一一对应，例如<code>NET_TX_SOFTIRQ</code>对应的处理函数存储在<code>softirq_vec[NET_TX_SOFTIRQ]</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">    TIMER_SOFTIRQ,</span><br><span class="line">    NET_TX_SOFTIRQ,</span><br><span class="line">    NET_RX_SOFTIRQ,</span><br><span class="line">    BLOCK_SOFTIRQ,</span><br><span class="line">    BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">    TASKLET_SOFTIRQ,</span><br><span class="line">    SCHED_SOFTIRQ,</span><br><span class="line">    HRTIMER_SOFTIRQ,</span><br><span class="line">    RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">    NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为什么创建新的软中断时，必须修改枚举类型并添加新的项？</p>
<blockquote>
<ol>
<li><strong>唯一性保证</strong>：<br>每个软中断必须有唯一的编号，枚举类型通过编译器确保不会出现重复值。</li>
<li><strong>静态数组索引</strong>：<br>软中断处理函数数组<code>softirq_vec</code>的索引依赖于枚举值。例如，新添加的软中断<code>MY_NEW_SOFTIRQ</code>必须对应数组中的特定位置。</li>
<li><strong>编译时验证</strong>：<br>通过枚举类型，内核在编译时就能检查软中断编号是否越界或冲突，避免运行时错误。</li>
</ol>
</blockquote>
<p>流程:</p>
<blockquote>
<ol>
<li>注册软中断的函数open_softirq(kernel&#x2F;softirq.c)</li>
</ol>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment">  * 将软中断类型和软中断处理函数加入到软中断序列中</span></span><br><span class="line"><span class="comment">  * @nr                                 - 软中断类型 索引号</span></span><br><span class="line"><span class="comment">  * @(*action)(struct softirq_action *) - 软中断处理的函数指针</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">/* softirq_vec是个struct softirq_action类型的数组 */</span></span><br><span class="line">     softirq_vec[nr].action = action;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当内核运行一个软中断处理程序的时候,他就会执行这个action函数</span></span><br><span class="line"><span class="comment"> * 参数指向相应softirq_action结构体的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_softirq_handler</span><span class="params">(<span class="keyword">struct</span> softirq_action *h)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 软中断处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  struct softirq_action 的定义也在 include&#x2F;linux&#x2F;interrupt.h 文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个结构体的字段是个函数指针，字段名称是action</span></span><br><span class="line"><span class="comment"> * 函数指针的返回指是void型</span></span><br><span class="line"><span class="comment"> * 函数指针的参数是 struct softirq_action 的地址，其实就是指向 softirq_vec 中的某一项</span></span><br><span class="line"><span class="comment"> *     如果 open_softirq 是这样调用的： open_softirq(NET_TX_SOFTIRQ, my_tx_action);</span></span><br><span class="line"><span class="comment"> *     my_tx_action 就是处理函数</span></span><br><span class="line"><span class="comment"> *     那么 my_tx_action 的参数就是 softirq_vec[NET_TX_SOFTIRQ]的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span>    (*action)(<span class="keyword">struct</span> softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>触发软中断 raise_softirq 参见 kernel&#x2F;softirq.c文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 触发某个中断类型的软中断</span></span><br><span class="line"><span class="comment"> * @nr - 被触发的中断类型</span></span><br><span class="line"><span class="comment"> * 从函数中可以看出，在处理软中断前后有保存和恢复寄存器的操作</span></span><br><span class="line"><span class="comment"> * 触发软中断前 “禁止中断” 是为了保证 pending 位图修改的原子性，避免并发场景下的竞态和数据不一致；而 “恢复状态” 是为了最小化对系统中断响应的影响，确保其他中断能正常处理。这一机制是内核在 “安全性” 和 “实时性” 之间的平衡设计，既保护了软中断触发的可靠性，又避免了过度屏蔽中断导致的系统性能下降。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    local_irq_save(flags);  <span class="comment">// 保存当前中断状态,并静止中断.</span></span><br><span class="line">    raise_softirq_irqoff(nr);</span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq_irqoff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span> &#123;</span><br><span class="line">    __raise_softirq_irqoff(nr);</span><br><span class="line">    <span class="keyword">if</span> (!in_interrupt())</span><br><span class="line">        wakeup_softirqd(); <span class="comment">// 唤醒软中断内核线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过设置pending位图（每个 CPU 一个）标记软中断待处理。</span></span><br><span class="line"><span class="comment"> * 若当前不在中断上下文，唤醒ksoftirqd内核线程处理软中断。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行软中断 do_softirq </p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> <span class="title function_">do_softirq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    __u32 pending;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断是否在中断处理中，如果正在中断处理，就直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (in_interrupt())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 保存当前寄存器的值 */</span></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 取得当前已注册软中断的位图 */</span></span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 循环处理所有已注册的软中断 */</span></span><br><span class="line">    <span class="keyword">if</span> (pending)</span><br><span class="line">        __do_softirq();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复寄存器的值到中断处理前 */</span></span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asmlinkage <span class="type">void</span> __do_softirq(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pending;</span><br><span class="line">    <span class="type">int</span> max_restart = MAX_SOFTIRQ_RESTART; <span class="comment">// 默认10次</span></span><br><span class="line">    <span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">    pending = local_softirq_pending(); <span class="comment">// 获取待处理软中断位图</span></span><br><span class="line">    account_system_vtime(current);</span><br><span class="line">    __local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);</span><br><span class="line">    lockdep_softirq_enter();</span><br><span class="line"></span><br><span class="line">    cpu = smp_processor_id();</span><br><span class="line">restart:</span><br><span class="line">    <span class="comment">/* Reset the pending bitmask before enabling irqs */</span></span><br><span class="line">    set_softirq_pending(<span class="number">0</span>); <span class="comment">// 清除位图</span></span><br><span class="line"></span><br><span class="line">    local_irq_enable(); <span class="comment">// 开中断，允许嵌套</span></span><br><span class="line"></span><br><span class="line">    h = softirq_vec;</span><br><span class="line">    <span class="keyword">while</span> ((softirq_bit = ffs(pending))) &#123; <span class="comment">// 查找待处理的最高位</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> vec_nr;</span><br><span class="line">        <span class="type">int</span> prev_count;</span><br><span class="line"></span><br><span class="line">        h += softirq_bit - <span class="number">1</span>; <span class="comment">// 定位到对应softirq_action</span></span><br><span class="line">        vec_nr = h - softirq_vec; <span class="comment">// 计算软中断编号</span></span><br><span class="line">        prev_count = preempt_count();</span><br><span class="line"></span><br><span class="line">        kstat_incr_softirqs_this_cpu(vec_nr);</span><br><span class="line"></span><br><span class="line">        trace_softirq_entry(vec_nr);</span><br><span class="line">        h-&gt;action(h); <span class="comment">// 调用处理函数！</span></span><br><span class="line">        trace_softirq_exit(vec_nr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(prev_count != preempt_count())) &#123;</span><br><span class="line">            printk(KERN_ERR <span class="string">&quot;huh, entered softirq %u %s %p&quot;</span></span><br><span class="line">                  <span class="string">&quot;with preempt_count %08x, exited with %08x?\n&quot;</span>,</span><br><span class="line">                  vec_nr, softirq_to_name[vec_nr],</span><br><span class="line">                  h-&gt;action, prev_count, preempt_count());</span><br><span class="line">            preempt_count() = prev_count;</span><br><span class="line">        &#125;</span><br><span class="line">        h++;</span><br><span class="line">        pending &gt;&gt;= softirq_bit; <span class="comment">// 右移，处理下一位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    local_irq_disable(); <span class="comment">// 关中断</span></span><br><span class="line"></span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line">    <span class="keyword">if</span> (pending &amp;&amp; --max_restart)</span><br><span class="line">        <span class="keyword">goto</span> restart; <span class="comment">// 若有新的软中断被触发，且未超过重试次数，继续处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pending)</span><br><span class="line">        wakeup_softirqd(); <span class="comment">// 若仍有待处理，唤醒内核线程</span></span><br><span class="line"></span><br><span class="line">    lockdep_softirq_exit();</span><br><span class="line">    account_system_vtime(current);</span><br><span class="line">    _local_bh_enable(SOFTIRQ_OFFSET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行相应的软中断 - 执行自己写的中断处理</p>
</li>
</ol>
<p>  znelinux中，执行软中断有专门的内核线程，每个处理器对应一个线程，名称ksoftirqd&#x2F;n (n对应处理器号)</p>
</blockquote>
<h4 id="2-2-tasklet"><a href="#2-2-tasklet" class="headerlink" title="2.2 tasklet"></a>2.2 tasklet</h4><p>tasklet也是利用软中断实现的，但是他提供了比软中断更好用的接口（实际就是基于软中断又封装了一下），所以除了对性能要求特别高的情况，一般建议使用tasklet来实现自己的中断。tasklet由两类软中断代表：HI_SOFTIRQ和TASKLET_SOFTIRQ。这两者的唯一区别就是前者优先级高。</p>
<p>tasklet对应的结构体在&lt;linux&#x2F;interrupt.h&gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 每个结构体代表一个 tasklet </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span> <span class="comment">/* 链表中的下一个tasklet */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> state;         <span class="comment">/* tasklet状态 */</span></span><br><span class="line">    <span class="type">atomic_t</span> count;              <span class="comment">/* 引用计数器 */</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">/* tasklet处理函数  和软中断的action一样，*/</span>  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;          <span class="comment">/* tasklet处理函数的参数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>tasklet状态只有3种值：</p>
<ol>
<li>值 0 表示该tasklet没有被调度</li>
<li>值 TASKLET_STATE_SCHED 表示该tasklet已经被调度</li>
<li>值 TASKLET_STATE_RUN 表示该tasklet正在运行</li>
</ol>
<p>引用计数器count 的值不为0，表示该tasklet被禁止，不允许被执行。只有当它为0，tasklet才被激活，并且在被设置为挂起状态时，该taaklet才能够执行。</p>
<p>tasklet的使用流程如下：</p>
<ol>
<li>声明tasklet</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参见linux/interrupt.h</span></span><br><span class="line"><span class="comment"> * 使用宏 静态声明一个tasklet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET(name, func, data) \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment">// 这段代码等价于</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">name</span> =</span> &#123; <span class="literal">NULL</span>, <span class="number">0</span>, ATOMIC_INIT(<span class="number">0</span>), func, data &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET_DISABLED(name, func, data) \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment">/*动态声明一个tasklet 传递一个tasklet_struct指针给初始化函数*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tasklet_init</span> <span class="params">(<span class="keyword">struct</span> tasklet_struct *t,</span></span><br><span class="line"><span class="params">             <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tasklet_init</span><span class="params">(t , tasklet_handler, dev)</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写处理程序</li>
</ol>
<p>参照tasklet处理函数的原型来写自己的处理逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_handler</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调度tasklet</li>
</ol>
<p>中断的上半部分处理完后调度tasklet，在适当时候进行下半部的处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklet_schedule(&amp;my_tasklet) <span class="comment">/* 这里的就是之前声明的，这里将my_tasklet标记为挂起。*/</span></span><br></pre></td></tr></table></figure>

<p>调度的流程：</p>
<h4 id="2-3-工作队列"><a href="#2-3-工作队列" class="headerlink" title="2.3 工作队列"></a>2.3 工作队列</h4><p>工作队列子系统是一个用于创建内核线程的接口，通过它可以创建一个工作者线程来专门处理中断的下半部工作，负责执行由内核其他部分排到队列里的任务。工作队列提供了一个缺省的工作者线程来处理这些工作。叫做events&#x2F;n（n对应处理器号）</p>
<p>工作队列和tasklet不一样，不是基于软中断来实现的。</p>
<p>工作队列主要用到下面三个结构体，弄懂了这三个结构体的关系！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 include/linux/workqueue.h 文件中定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span> data;             <span class="comment">/* 这个并不是处理函数的参数，而是表示此work是否pending等状态的flag */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORK_STRUCT_PENDING 0        <span class="comment">/* T if work item pending execution */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORK_STRUCT_FLAG_MASK (3UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORK_STRUCT_WQ_DATA_MASK (~WORK_STRUCT_FLAG_MASK)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span>         <span class="comment">/* 中断下半部处理函数的链表 */</span></span><br><span class="line">    <span class="type">work_func_t</span> func;               <span class="comment">/* 处理中断下半部工作的函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 kernel/workqueue.c文件中定义</span></span><br><span class="line"><span class="comment"> * 每个工作者线程对应一个 cpu_workqueue_struct ，其中包含要处理的工作的链表</span></span><br><span class="line"><span class="comment"> * (即 work_struct 的链表，当此链表不空时，唤醒工作者线程来进行处理)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The per-CPU workqueue (if single thread, we always use the first</span></span><br><span class="line"><span class="comment"> * possible cpu).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">spinlock_t</span> lock;                   <span class="comment">/* 锁保护这种结构 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">worklist</span>;</span>         <span class="comment">/* 工作队列头节点 */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> more_work;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">current_work</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span>       <span class="comment">/* 关联工作队列结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span>;</span>        <span class="comment">/* 关联线程 */</span></span><br><span class="line">&#125; ____cacheline_aligned;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 也是在 kernel/workqueue.c 文件中定义的</span></span><br><span class="line"><span class="comment"> * 每个 workqueue_struct 表示一种工作者类型，系统默认的就是 events 工作者类型</span></span><br><span class="line"><span class="comment"> * 每个工作者类型一般对应n个工作者线程，n就是处理器的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The externally visible workqueue abstraction is an array of</span></span><br><span class="line"><span class="comment"> * per-CPU workqueues:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> *<span class="title">cpu_wq</span>;</span>  <span class="comment">/* 工作者线程 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> singlethread;</span><br><span class="line">    <span class="type">int</span> freezeable;        <span class="comment">/* Freeze threads during suspend */</span></span><br><span class="line">    <span class="type">int</span> rt;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用工作队列</li>
</ul>

    </div>

    
    
    

     
   <div>
     <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
   </div>
 
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>gb
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2025/08/02/Linux%20%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="">http://example.com/2025/08/02/Linux 内核设计与实现/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/08/02/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.</span> <span class="nav-text">Linux 内核设计与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">第三章 进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">3.1进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.2.</span> <span class="nav-text">3.2 进程描述符和任务结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.1.3.</span> <span class="nav-text">3.3 进程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%B6%E6%97%8F%E6%95%B0"><span class="nav-number">1.1.4.</span> <span class="nav-text">3.4 进程的家族数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.1.5.</span> <span class="nav-text">3.5 进程的创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">1.2.</span> <span class="nav-text">第四章 进程调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">第七章 中断处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86%E5%92%8C%E6%8E%A8%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.4.</span> <span class="nav-text">下半部分和推后执行的工作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%A4%84%E7%90%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 中断下半部处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. 实现中断下半部的机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">2.1 软中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-tasklet"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">2.2 tasklet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">2.3 工作队列</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gb"
      src="/images/20210404011504_4219e.png">
  <p class="site-author-name" itemprop="name">gb</p>
  <div class="site-description" itemprop="description">路漫漫其修远兮</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2025-07 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gb</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">12k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">11 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
